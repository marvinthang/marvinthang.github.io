---
title: x86-64 ISA
date: 2026-02-23 00:00:00 +0800
categories: [assembly]
tags: [x86-64, assembly]
description: x86-64 Instruction Set Architecture
math: true
---

```cmd
gcc -Og -S code.c
gcc -Og -c code.c
objdump -d code.o
```

## Registers

| 8 bytes | 4 bytes | 2 bytes | 1 byte | Purpose       |
| ------- | ------- | ------- | ------ | ------------- |
| %rax    | %eax    | %ax     | %al    | Return value  |
| %rbx    | %ebx    | %bx     | %bl    | Callee-saved  |
| %rcx    | %ecx    | %cx     | %cl    | 4th argument  |
| %rdx    | %edx    | %dx     | %dl    | 3rd argument  |
| %rsi    | %esi    | %si     | %sil   | 2nd argument  |
| %rdi    | %edi    | %di     | %dil   | 1st argument  |
| %rbp    | %ebp    | %bp     | %bpl   | Callee-saved  |
| %rsp    | %esp    | %sp     | %spl   | Stack pointer |
| %r8     | %r8d    | %r8w    | %r8b   | 5th argument  |
| %r9     | %r9d    | %r9w    | %r9b   | 6th argument  |
| %r10    | %r10d   | %r10w   | %r10b  | Caller-saved  |
| %r11    | %r11d   | %r11w   | %r11b  | Caller-saved  |
| %r12    | %r12d   | %r12w   | %r12b  | Callee-saved  |
| %r13    | %r13d   | %r13w   | %r13b  | Callee-saved  |
| %r14    | %r14d   | %r14w   | %r14b  | Callee-saved  |
| %r15    | %r15d   | %r15w   | %r15b  | Callee-saved  |

The name follow multiple history conventions:
- The original 8086 had 8 16-bit registers from `%ax` to` %bp`.
- The IA32 expanded the registers to 32 bits from `%eax` to `%ebp`.
- The x86-64 further expanded the registers to 64 bits from `%rax` to `%rbp`, and added 8 more registers from `%r8` to `%r15`.

## Operand Specifiers

| Type      | Form               | Operand value                  | Name                |
| --------- | ------------------ | ------------------------------ | ------------------- |
| Immediate | `$Imm`             | `Imm`                          | Immediate           |
| Register  | `r_a`              | `R[r_a]`                       | Register            |
| Memory    | `Imm`              | `M[Imm]`                       | Absolute            |
| Memory    | `(r_a)`            | `M[R[r_a]]`                    | Indirect            |
| Memory    | `Imm(r_b)`         | `M[Imm + R[r_b]]`              | Base + displacement |
| Memory    | `(r_b, r_i)`       | `M[R[r_b] + R[r_i]]`           | Indexed             |
| Memory    | `Imm(r_b, r_i)`    | `M[Imm + R[r_b] + R[r_i]]`     | Indexed             |
| Memory    | `(, r_i, s)`       | `M[R[r_i] · s]`                | Scaled indexed      |
| Memory    | `Imm(, r_i, s)`    | `M[Imm + R[r_i] · s]`          | Scaled indexed      |
| Memory    | `(r_b, r_i, s)`    | `M[R[r_b] + R[r_i] · s]`       | Scaled indexed      |
| Memory    | `Imm(r_b, r_i, s)` | `M[Imm + R[r_b] + R[r_i] · s]` | Scaled indexed      |

> The scaling factor `s` can only be 1, 2, 4, or 8.
{: .prompt-info}

> In memory operands, the base register `r_b` and the index register `r_i` must be 8-byte registers. `%rsp` cannot be used as an index register.
{: .prompt-warning}

## Data Movement Instructions (mov)

### Simple data movement instructions

- **MOV S, D** $\rightarrow$ `D ← S` - Move  
  - `movb` - Move byte  
  - `movw` - Move word  
  - `movl` - Move double word  
  - `movq` - Move quad word  


Source operand can be immediate, register, or memory.
Destination operand can be register or memory.

> `mov` does not support memory-to-memory moves, but we can use a register as an intermediate (requires 2 instructions).
{: .prompt-warning}

For most cases, `mov` will only update the destination register bytes and memory bytes, and leave the other bytes unchanged. The only exception is when `movl` has a register destination, it will set the upper 4 bytes to 0.

- `movabsq` I, R $\rightarrow$ `R ← I` — Move absolute quad word

The regular `movq` can only move a 32-bit immediate to a register, then sign-extend it to 64 bits. If we want to move a 64-bit immediate, we need to use `movabsq` instead.

```isa
movabsq $0x0011223344556677, %rax    # %rax = 0011223344556677
movb    $-1, %al                     # %rax = 00112233445566FF
movw    $-1, %ax                     # %rax = 001122334455FFFF
movl    $-1, %eax                    # %rax = 00000000FFFFFFFF
movq    $-1, %rax                    # %rax = FFFFFFFFFFFFFFFF
```

### Zero-extending data movement instructions

- **MOVZ S, R** $\rightarrow$ `R ← ZeroExtend(S)` - Move with zero extension  
  - `movzbw` - Move zero-extended byte to word
  - `movzbl` - Move zero-extended byte to double word
  - `movzwl` - Move zero-extended word to double word
  - `movzbq` - Move zero-extended byte to quad word
  - `movzwq` - Move zero-extended word to quad word

Source operand can be register or memory, but not immediate. 
Destination operand must be a register.

> `movzlq` does not exist, because `movl` already zero-extends the source to 64 bits when the destination is a register.
{: .prompt-info}

### Sign-extending data movement instructions

- **MOVS S, R** $\rightarrow$ `R ← SignExtend(S)` - Move with sign extension  
  - `movsbw` - Move sign-extended byte to word
  - `movsbl` - Move sign-extended byte to double word
  - `movswl` - Move sign-extended word to double word
  - `movsbq` - Move sign-extended byte to quad word
  - `movswq` - Move sign-extended word to quad word
  - `movslq` - Move sign-extended double word to quad word

- `cltq` (no operand) $\rightarrow$ `%rax ← SignExtend(%eax)` - sign-extend `%eax` to `%rax` (equivalent to `movslq %eax, %rax`)

```isa
movabsq $0x0011223344556677, %rax    # %rax = 0011223344556677
movb    $0xAA, %dl                   # %dl  = AA
movb    %dl, %al                     # %rax = 00112233445566AA
movsbq  %dl, %rax                    # %rax = FFFFFFFFFFFFFFAA
movzbq  %dl, %rax                    # %rax = 00000000000000AA
```
### Pushing and Popping Stack Data

`rsp` is the stack pointer, which points to the top of the stack. The stack grows downwards, so pushing data onto the stack will decrease `rsp`, and popping data from the stack will increase `rsp`.

- `pushq S` $\rightarrow$ `R[%rsp] ← R[%rsp] - 8; M[R[%rsp]] ← S` - Push quad word
- `popq D`  $\rightarrow$ `D ← M[R[%rsp]]; R[%rsp] ← R[%rsp] + 8` - Pop quad word

## Arithmetic and Logical Operations

### Load Effective Address

- `leaq S, R` $\rightarrow$ `R ← &S` - Load effective address

It has the form of an instruction that reads from memory to a register, but it does not read from memory. Instead, it computes the effective address of the source operand and stores it in the destination register.

Example: if `R[%rdx] = x`, then `leaq 7(%rdx, %rdx, 4), %rax` will set `%rax` to `7 + x + 4x = 7 + 5x`.

The destination operand must be a register, but the source operand can be an immediate, register, or memory operand.

> `leaq` has no variant for operands of different sizes (like `leal` or `leaw`), because the effective address is always a 64-bit value.
{: .prompt-warning}

> Compilers often find clever uses of leaq that have nothing to do with
effective address computations.
{: .prompt-tip}

### Unary and Binary Operations

| Instruction   | Effect                     | Description      |
| ------------- | -------------------------- | ---------------- |
| **INC D**     | $D \leftarrow D + 1$       | Increment        |
| **DEC D**     | $D \leftarrow D - 1$       | Decrement        |
| **NEG D**     | $D \leftarrow -D$          | Negate           |
| **NOT D**     | $D \leftarrow \sim D$      | Bitwise NOT      |
| **ADD S, D**  | $D \leftarrow D + S$       | Add              |
| **SUB S, D**  | $D \leftarrow D - S$       | Subtract         |
| **IMUL S, D** | $D \leftarrow D \times  S$ | Integer multiply |
| **XOR S, D**  | $D \leftarrow D \oplus S$  | Bitwise XOR      |
| **OR S, D**   | $D \leftarrow D \mid S$    | Bitwise OR       |
| **AND S, D**  | $D \leftarrow D \& S$      | Bitwise AND      |

- Unary operand can be either register or memory, but not immediate. 

- Binary source operand can be immediate, register, or memory.
Binary destination operand can be either register or memory. 
Operands cannot both be memory locations.

> When the destination operand is a memory location, the processor will first read the value from memory, perform the operation, and then write the result back to memory.
{: .prompt-info}

### Shift Operations

| Instruction  | Effect                   | Description                          |
| ------------ | ------------------------ | ------------------------------------ |
| **SAL S, D** | $D \leftarrow D \<< S$   | Arithmetic left shift                |
| **SHL S, D** | $D \leftarrow D \<< S$   | Logical left shift (same as **SAL**) |
| **SAR S, D** | $D \leftarrow D \>>_A S$ | Arithmetic right shift               |
| **SHR S, D** | $D \leftarrow D \>>_L S$ | Logical right shift                  |

The shift amount `S` can be an immediate value or the value in the single-byte `%cl` register. 
The destination operand `D` can be a register or a memory location, but not an immediate value.

1-byte shift amount would make the shift amount up to 255. However, with x86-64, a shift instruction on value that are $m$-bits long will only consider the lower $\log_2 m$ bits of the shift amount. 
- For example, when `%cl = 0xFF`, then `salb` shifts by 7, `salw` shifts by 15, `sall` shifts by 31, and `salq` shifts by 63.

> No **DIV** or **MOD** instruction for normal division and modulus, but there are `idiv` and `div` instructions for signed and unsigned division respectively, which will be covered in the next section.
{: .prompt-info}

### Oct word (16 bytes)

The x86-64 instruction set provides limited support for operations involving 128-bit (16-byte) numbers.

| Instruction | Effect                                                               | Description            |
| ----------- | -------------------------------------------------------------------- | ---------------------- |
| `imulq S`   | `R[%rdx]:R[%rax] ← S * R[%rax]`                                      | signed full multiply   |
| `mulq S`    | `R[%rdx]:R[%rax] ← S * R[%rax]`                                      | unsigned full multiply |
| `cqto`      | `R[%rdx]:R[%rax] ← SignExtend(R[%rax])`                              | convert to oct-word    |
| `idivq S`   | `R[%rax] ← R[%rdx]:R[%rax] / S` <br> `R[%rdx] ← R[%rdx]:R[%rax] % S` | signed divide          |
| `divq S`    | `R[%rax] ← R[%rdx]:R[%rax] / S` <br> `R[%rdx] ← R[%rdx]:R[%rax] % S` | unsigned divide        |

`imulq` has 2 different form, with this 1-operand form being the only way to multiply two 64-bit numbers to get a 128-bit result. The other form of `imulq` with 2 or 3 operands only produces a 64-bit result.

> `idiv` only have 1 form with 1 operand, not 2 like `imul`.
{: .prompt-warning}
