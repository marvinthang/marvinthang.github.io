---
title: C++ Features
date: 2026-02-21 15:00:00 +0800
categories: [cpp]
tags: [cpp, c++]
description: Some cool C++ features
math: true
---

ngu
## Array indexing
```cpp
int arr[5] = {1, 2, 3, 4, 5};
printf("%d\n", arr[3]); // prints: 4
printf("%d\n", 3[arr]); // also prints: 4
```
In C++, `arr[3]` is equivalent to `*(arr + 3)`, which means "the value at the address obtained by adding 3 to the base address of `arr`". 

Similarly, `3[arr]` is equivalent to `*(3 + arr)`, which is the same as `*(arr + 3)`. 

Therefore, both expressions access the same element in the array, resulting in the same output.

## Struct alignment
```cpp
struct A {
    char  a;   // 1 byte [+3 bytes padding]
    int   b;   // 4 bytes, wants 4-aligned
    char  c;   // 1 byte [+3 bytes padding]
};

printf("%zu\n", sizeof(A)); // prints: 12
```

In C++, the size of a struct is determined not only by the sizes of its members but also by the alignment requirements of those members.

In struct `A`, `b` is an `int` which requires 4-byte alignment. 
This means that the compiler will insert padding bytes to ensure that `b` is aligned on a 4-byte boundary:
- `a` takes 1 byte, followed by 3 bytes of padding to align `b` on a 4-byte boundary.
- `b` takes 4 bytes.
- `c` takes 1 byte, followed by 3 padding bytes to ensure the total size of the struct is a multiple of the largest alignment requirement (which is 4 bytes in this case).

Reordering the members of the struct can reduce the size:
```cpp
struct B {
    char  a;   // 1 byte
    char  c;   // 1 byte [+2 bytes padding]
    int   b;   // 4 bytes, wants 4-aligned
};

printf("%zu\n", sizeof(B)); // prints: 8
```
In struct `B`, the members are ordered such that `a` and `c` are together, taking 2 bytes, followed by 2 bytes of padding to align `b` on a 4-byte boundary. 
This results in a total size of 8 bytes for struct `B`, which is more efficient than struct `A`.

## Compiler optimizations
```cpp
int x = 5;
int y = x * 2; // Compiler can optimize this to: int y = 10;
```
In C++, compilers can perform various optimizations to improve the performance of the code. 
In the example above, the compiler can evaluate the expression `x * 2` at compile time since `x` is a constant value. 
This allows the compiler to replace the expression with
the computed value `10`, resulting in more efficient code.

## Unsafe behavior in C std library
```c++
char buffer[10];
strcpy(buffer, "This is a long string that exceeds the buffer size!"); // Unsafe
```
In C, the `strcpy` function does not perform bounds checking on the destination buffer.
If the source string exceeds the size of the destination buffer, it can lead to a buffer overflow, which is a common security vulnerability.
In C++, it is recommended to use safer alternatives like `std::string` or `std::strncpy` to avoid such issues.

Another example, `atoi`.
```c++
char str[] = "xyz";
int num = atoi(str); // Unsafe if str is not a valid number
```

## Digraphs and Trigraphs

| Original | Digraph | Trigraph |
| -------- | ------- | -------- |
| {        | <%      | ??<      |
| }        | %>      | ??>      |
| [        | <:      | ??(      |
| ]        | :>      | ??)      |
| #        | %:      | ??=      |

In C++, digraphs and trigraphs are alternative representations for certain characters that may not be available on all keyboards or in all character sets.
- Digraphs are two-character sequences that represent a single character. For example, `<%` represents `{`, and `%>` represents `}`.
- Trigraphs are three-character sequences that represent a single character. For example, `??=` represents `#`.

While these features were introduced to provide compatibility with different character sets, they are rarely used in modern C++ programming and can lead to confusion. It is generally recommended to avoid using digraphs and trigraphs in C++ code to improve readability and maintainability.

Digraphs:
```c++
%:include <iostream>

int main() <%
    char name<:3:> = "Bob";
    return 0;
%>
```
Trigraphs:
```c++
??=include <iostream>

int main() ??<
    char name??(3??) = "Bob";
    return 0;
??>
```

## `main` is not `_start`
```c++
void _start() {
    set_up_libc();
    int argc = read_argc();
    char **argv = read_argv();
    exit(main(argc, argv));
}
```
In C++, the `main` function is the entry point of the program, but it is not the actual starting point of the program. 

The `_start` function is the true entry point, which is called by the operating system when the program is executed. 

The `_start` function is responsible for setting up the runtime environment, including initializing the C++ standard library, and then it calls the `main` function with the appropriate arguments.

## C++ doesn't know a byte is 8 bits
```c++
static_assert(sizeof(char) == 1, "A byte must be 8 bits");
```
In C++, the size of a `char` is defined to be 1 byte, but the actual number of bits in a byte can vary depending on the architecture and platform.

The C++ standard does not specify that a byte must be 8 bits, and it allows for the possibility of different byte sizes.
However, in practice, most modern architectures use 8-bit bytes, and it is common to assume that a byte is 8 bits when writing C++ code.

## Literal prefixes
```c++
auto binary = 0b1010; // Binary literal (10 in decimal)
auto octal = 012;     // Octal literal (10 in decimal)
auto hex = 0xA;       // Hexadecimal literal (10 in decimal)
```
In C++, you can use literal prefixes to specify the base of integer literals.
- `0b` or `0B` is used for binary literals, which represent numbers in base 2.
- A leading `0` is used for octal literals, which represent numbers in base 8.
- `0x` or `0X` is used for hexadecimal literals, which represent numbers in base 16.
These prefixes allow you to write integer literals in different bases, making it easier to work with binary, octal, and hexadecimal values in your C++ code.

